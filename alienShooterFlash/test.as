package  {		import flash.display.Sprite;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.ui.*;	import flash.text.*;	import flash.sampler.StackFrame;	import fl.motion.easing.Back;			public class Main extends Sprite 	{				//Explanation of "magic" numbers 		private const ROT_SPEED:uint = 2; //rotate speed for the cannon		private const R:uint = 18; //set radius for the bubbles 		private const D:Number=R*Math.sqrt(3); //distance between center of the bubbles 		private const DEG_TO_RAD:Number=0.0174532925;  //conversion rate 		private const BUBBLE_SPEED:uint=15; //speed the bubble travels		private const numRows:uint = 14;		private const numValidRows:uint = 13;		private const evenCols:uint = 8; 		private const oddCols:uint = 7; 				//Boolean variables 		private var left: Boolean = false;		private var right: Boolean = false;		private var gameOver: Boolean = false;		private var gameLost: Boolean = false; 		private var fire:Boolean=false; 		private var gridBuilding:Boolean=false;				//Objects used on the game field 		private var bubCont:Sprite; 		private var borderLine:Sprite;		private var bubble:bubble_mc; //bubble object 		private var cannon:cannon_mc; //cannon object 				//Setting up variables to keep score 		private var gameScoreField:TextField = new TextField();		private static const pointsForConnection:int = 100;		private var gameScore:int = 0;				//Images used to denote the game has been completed		private var gameOverLose:String = "<img src = 'gameoverlose.gif'>";		private var gameOverWin:String = "<img src = 'winner.jpg'>";		private var gameOverField:TextField = new TextField();						private var vx,vy:Number; //velocity of the bubbles in the X and Y direction 				//Arrays to hold sets of bubbles		private var fieldArray:Array; //array to hold bubbles of the entire field 		private var chainArray:Array; //array to hold chains of bubble of the same color that is connected		private var connArray:Array; //array to hold which bubble are connected to 						public function Main() 		{			debugPlaceContainer(); // YLW: change placeContainer() to debugPlaceContainer()			//buildGrid();			placeCannon();			//loadBubble();			//showGameScore();			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKDown);			stage.addEventListener(KeyboardEvent.KEY_UP, onKUp);			addEventListener(Event.ENTER_FRAME, onEFrame);		}				///////////////////////////// YLW: added for debug purposes /////////////////////////////		private function debugPlaceContainer():void 		{			// YLW: commented out the original: fieldArray=new Array();			fieldArray = [	[0,0,0,0,4,0,0,5],							[0,0,0,4,0,0,5],							[0,0,0,0,0,0,0,0],							[0,0,0,0,0,0,0],							[0,0,0,0,0,0,0,0],							[0,0,0,0,0,0,0],							[0,0,0,0,0,0,0,0],							[0,0,0,0,0,0,0],							[0,0,0,0,0,0,0,0],							[0,0,0,0,0,0,0],							[0,0,0,0,0,0,0,0],							[0,0,0,0,0,0,0],							[0,0,0,0,0,0,0,0],							[0,0,0,0,0,0,0]];			     		bubCont=new Sprite();			borderLine= new Sprite();     		addChild(bubCont);			addChild(borderLine);     		bubCont.graphics.lineStyle(1,0xffffff,0.2);			//Draws borderline to indicate where right edge of the field is			borderLine.graphics.lineStyle(10,0xffffff,0.2);			borderLine.graphics.moveTo(16*R+8,0);			borderLine.graphics.lineTo(16*R+8, 480);						gridBuilding = true;     		for(var i:uint=0;i<numRows;i++)			{				//fieldArray[i] = new Array();       			for(var j:uint=0;j<evenCols;j++)				{					//if it's an even row start grid at the left side of the screen 					if (i%2==0) 					{          				//bubCont.graphics.drawCircle(R+j*R*2,R+i*D,R);						// YLW: commented out the original: fieldArray[i][j]=0;						//Load the first 7 rows with bubbles						if(i<8 && fieldArray[i][j] > 0)						{							bubble = new bubble_mc();							bubCont.addChild(bubble);	// YLW: addChild to bubCont							bubble.gotoAndStop(fieldArray[i][j]);							bubble.x = R+j*R*2;							bubble.y = R+i*D;							bubble.name=i+","+j; // YLW: commented out the original: parkBubble();						}					}else{						//if it's an odd row start grid slightly offset of left side of screen						//odd rows contain one less column than even rows 						if (j<oddCols) 	// YLW to JD: why check j < oddCols						{								//bubCont.graphics.drawCircle(2*R+j*R*2,R+i*D,R);								// YLW: commented out the original: fieldArray[i][j]=0;								//Build the first 7 rows with bubbles 								if(i<8 && fieldArray[i][j] > 0)								{									bubble = new bubble_mc();									bubCont.addChild(bubble);	// YLW: addChild to bubCont, not this									bubble.gotoAndStop(fieldArray[i][j]);									bubble.x = 2*R+j*R*2;									bubble.y = R+i*D;									bubble.name=i+","+j ;// YLW: commented out the original: parkBubble();								}						}					}				} 			}			gridBuilding = false;			loadBubble();					} //end of place container function 				private function debugLoadBubbleWithFrameNum(f:int):void 		{			checkForGameOver();			bubble = new bubble_mc();     		addChild(bubble);     		bubble.gotoAndStop(f);     		bubble.x=R*8;     		bubble.y=450;		}				public function debugPrintFieldArray():void		{			for (var i:int = 0; i < fieldArray.length; i++)			{				trace("[" + fieldArray[i] + "],");			}		}				public function debugPrintStateUponFire():void		{			trace("----------");			trace("fieldArray BEFORE fire:");			debugPrintFieldArray();			trace("bullet color: " + bubble.currentFrame);			trace("canon rotation: " + cannon.rotation);			trace("----------");		}		///////////////////////////// end YLW: added for debug purposes /////////////////////////////				/*		* Function to place cannon at the bottom of screen		* and halfway across the screen 		*/ 	    private function placeCannon():void 		{     		cannon=new cannon_mc();     		addChild(cannon);     		cannon.y=450;     		cannon.x=R*8;   		}				/*		* Function that handles when the user presses one of the arrow keys		* on the keyboard 		*		private function onKDown(e:KeyboardEvent):void 		{			trace("Entered the OnKDown method");      		switch (e.keyCode) 			{				//user hits the left arrow, cannon spins left        			case 37 :         			left=true;        			 break;				//user hits the right arrow, cannon spins right 	        			case 39 :         			right=true;        			 break;				//user hits up arrow, fires bubble 	 				case 38 :					if (! fire) 					{						fire=true;           				var radians=(cannon.rotation-90)*DEG_TO_RAD;           				vx=BUBBLE_SPEED*Math.cos(radians);           				vy=BUBBLE_SPEED*Math.sin(radians);												///////////////////////////// YLW: added for debug purposes /////////////////////////////						debugPrintStateUponFire();						///////////////////////////// end YLW: added for debug purposes /////////////////////////////					}					break;									///////////////////////////// YLW: added for debug purposes /////////////////////////////				case Keyboard.NUMBER_1: trace("Pressed Number 1"); debugLoadBubbleWithFrameNum(1); break;				case Keyboard.NUMBER_2: debugLoadBubbleWithFrameNum(2); break;				case Keyboard.NUMBER_3: debugLoadBubbleWithFrameNum(3); break;				case Keyboard.NUMBER_4: debugLoadBubbleWithFrameNum(4); break;				case Keyboard.NUMBER_5: debugLoadBubbleWithFrameNum(5); break;				case Keyboard.SPACE: debugPrintStateUponFire(); break;				///////////////////////////// end YLW: added for debug purposes /////////////////////////////			} 						trace("Key that was pressed was: " + e.keyCode); 			trace("Expected key was: " + Keyboard.NUMBER_1); 		}*/						/*		* Function that handles when the user is not pressing on 		* on the keyboard 		*/		private function onKUp(e:KeyboardEvent):void 		{     		switch (e.keyCode) 			{       			case 37 :         			left=false;        			 break;       			case 39 :         			right=false;        			 break;			} 					}		private function onEFrame(e:Event):void 		{			//user hits the left arrow and rotates the cannon to the left      		if (left)        			cannon.rotation-=ROT_SPEED;    					//rotate the cannon to the right when the user hits the right arrow     		if (right)        			cannon.rotation+=ROT_SPEED; 							//code to handle once bubble has been fired 			//handles bub			if (fire) 			{				bubble.x+=vx;				bubble.y+=vy;								//when bubble bounces off the wall respond accordingly 				if (bubble.x<R) 				{					bubble.x=R;					vx*=-1; }       			if (bubble.x>R*15) 				{         			bubble.x=R*15;         			vx*=-1;       			}				//if bubble hits the top of the screen, locks in       			if (bubble.y<R) 				{					parkBubble();       			}								//check all bubbles in grid to see if bubble that has been fired has collided				//with them				else 				{					for (var i:uint = 0; i<bubCont.numChildren; i++)					{						var tmp:bubble_mc;						tmp = bubCont.getChildAt(i) as bubble_mc;						if (collide(tmp))						{							parkBubble();							break;						}					}				}			}		}				/*		* Function to build grid and background		*/		private function placeContainer():void 		{			fieldArray=new Array();			     		bubCont=new Sprite();			borderLine= new Sprite();     		addChild(bubCont);			addChild(borderLine);     		bubCont.graphics.lineStyle(1,0xffffff,0.2);			//Draws borderline to indicate where right edge of the field is			borderLine.graphics.lineStyle(10,0xffffff,0.2);			borderLine.graphics.moveTo(16*R+8,0);			borderLine.graphics.lineTo(16*R+8, 480);						gridBuilding = true;     		for(var i:uint=0;i<numRows;i++)			{				fieldArray[i] = new Array();       			for(var j:uint=0;j<evenCols;j++)				{					//if it's an even row start grid at the left side of the screen 					if (i%2==0) 					{          				//bubCont.graphics.drawCircle(R+j*R*2,R+i*D,R);						fieldArray[i][j]=0;						//Load the first 7 rows with bubbles						if(i<8)						{							bubble = new bubble_mc();							addChild(bubble);							bubble.gotoAndStop(Math.floor(Math.random()*5)+1);	// YLW: commented out the original: bubble.gotoAndStop(Math.floor(Math.random()*5))+1;							bubble.x = R+j*R*2;							bubble.y = R+i*D;							parkBubble();						}					}else{						//if it's an odd row start grid slightly offset of left side of screen						//odd rows contain one less column than even rows 						if (j<oddCols) 						{								//bubCont.graphics.drawCircle(2*R+j*R*2,R+i*D,R);								fieldArray[i][j]=0;								//Build the first 7 rows with bubbles 								if(i<8)								{									bubble = new bubble_mc();									addChild(bubble);									bubble.gotoAndStop(Math.floor(Math.random()*5)+1);	// YLW: commented out the original: bubble.gotoAndStop(Math.floor(Math.random()*5))+1;									bubble.x = 2*R+j*R*2;									bubble.y = R+i*D;									parkBubble();								}						}					}				} 			}			gridBuilding = false;			loadBubble();					} //end of place container function 						/*		* Function to load a new bubble into the cannon		*/ 		private function loadBubble():void 		{			checkForGameOver();			bubble = new bubble_mc();     		addChild(bubble);     		bubble.gotoAndStop(Math.floor(Math.random()*5)+1);	// YLW commented out the original: bubble.gotoAndStop(Math.floor(Math.random()*5))+1;     		bubble.x=R*8;     		bubble.y=450;		}				/*		*Function that checks if the game has been 		*completed and brings up an image indicating		*whether the user won or lost 		*/ 		private function checkForGameOver():void		{			gameOver = true;						//////////////////// YLW: fixing the bug regarding premature winning ////////////////////			if (bubCont.numChildren > 0) gameOver = false;			//////////////////// end YLW: fixing the bug regarding premature winning ////////////////////						for(var j:uint = 0;j<evenCols ;j++)			{				//if bubble all the bubbles have been cleared or if				//a bubble is in the same line as the cannon				//end the game				if(fieldArray[0][j] != 0 && j != evenCols-1 && fieldArray[13][j] == 0)				{					gameOver = false;				}				else if(j != evenCols-1 && fieldArray[13][j] != 0)				{ 					gameOver = true;					gameLost = true;					break;				}				// YLW to JD: What if (j == evenCols-1)? -- a BUG regarding premature winning. See the new if statement before this for-loop above for a possible way to fix the bug.			}			if(gameOver) 			{				gameOverField.width = 405;             	gameOverField.height = 350;             	gameOverField.multiline = true;             	gameOverField.wordWrap = true;             	//gameOverField.border = true;              	addChild(gameOverField); 				if(gameLost)            		gameOverField.htmlText = gameOverLose;				else					gameOverField.htmlText = gameOverWin;			}		}				/*		* Function to lock bubble in the grid		*/		private function parkBubble():void		{			var row:uint=Math.floor(bubble.y/D);			var col:uint;						//depending on the row changes the way the column is calculated			if (row%2==0)				col = Math.floor(bubble.x/(R*2));			else				col = Math.floor((bubble.x-R)/(R*2));							////////// YLW to JD: Need to check if the cell has been occupied //////////			if (fieldArray[row][col] > 0)			{				row++;				if (row%2==0)					col = Math.floor(bubble.x/(R*2));				else					col = Math.floor((bubble.x-R)/(R*2));			}			////////// end YLW to JD: Need to check if the cell has been occupied //////////			     		var placed_bubble:bubble_mc = new bubble_mc();     		bubCont.addChild(placed_bubble);						//place bubbles in correct column depending on the row 			if (row%2==0)     			placed_bubble.x=(col*R*2)+R;			else				placed_bubble.x=(col*R*2)+2*R;				     		placed_bubble.y=(row*D)+R;     		placed_bubble.gotoAndStop(bubble.currentFrame);			placed_bubble.name=row+","+col;			fieldArray[row][col]=bubble.currentFrame; 			chainArray=new Array();			getChain(row,col); 						//if 3 bubbles of the same color are connected, remove those bubbles and any corresponding			if (chainArray.length>2 && gridBuilding == false)			{				for(var i:uint=0; i<chainArray.length; i++)				{					gameScore += pointsForConnection;					showGameScore();					with (bubCont)					{						removeChild(getChildByName(chainArray[i]));					}					var coords:Array=chainArray[i].split(",");					fieldArray[coords[0]][coords[1]]=0;				}				removeNotConnected();			}									trace("chain: "+chainArray);			trace("chain array length is: " + chainArray.length);						     		removeChild(bubble);     		fire=false;			if(gridBuilding == false)     			loadBubble();   		}				/*		*Function to show the game score 		*on the right side of the screen 		*/		private function showGameScore():void 		{			gameScoreField.width = 245; 			//gameScoreField.length = 200; 			gameScoreField.background = true; 			gameScoreField.backgroundColor = 0x00ffff;			addChild(gameScoreField);			gameScoreField.x = 300;			gameScoreField.text = "Score: "+String(gameScore);		}				/*		* Function that determines if two bubbles have collided		*/		private function collide (bub:bubble_mc):Boolean		{			var dist_x:Number=bub.x-bubble.x;			var dist_y:Number=bub.y-bubble.y;			return Math.sqrt(dist_x*dist_x+dist_y*dist_y)<=2*R-4;		}				/*		* Function passed a row and column will check and see if its valid		*/		private function getValue (row:int, col:int) :int 		{			if (fieldArray[row] == null)				return -1;			if (fieldArray[row][col]==null)				return -1;							return fieldArray[row][col];		}				/*		* Function that checks and see if when a bubble locks in, if it is part of a new chain		* by checking to make sure it's in a valid row and column and it's color is not currently in 		* the chain array		*/		private function isNewChain(row:int,col:int,val:uint):Boolean		{			return val == getValue(row,col)&&chainArray.indexOf(row+","+col)==-1;		}						/*		* Function that given a row and column checks surrounding spots and sees if they match the 		* color of the bubble in the given location		*/		private function getChain(row:int, col:int):void		{			chainArray.push(row+","+col);			var odd:uint = row%2;			var match:uint = fieldArray[row][col];			for (var i:int = -1; i<=1; i++)			{				for (var j:int = -1; j<=1; j++) 				{					if(i!=0 || j !=0) 					{						if (i==0||j==0||(j==-1&&odd==0)||(j==1&&odd==1)) 						{             				if (isNewChain(row+i,col+j,match)) 							{               					getChain(row+i,col+j);							}						}					}				}			}		} //end of getChain function				/*		* Function that tells in a given position in the grid		* if a bubble exists and if it has any connections 		* @param(row:int, col:int) 		* return Boolean		*/ 		private function isNewConnection(row:int,col:int):Boolean{			return getValue(row,col)>0 && connArray.indexOf(row+","+col) == -1;		}				/*		*Function that given a position 		*checks for connections at that position 		*and surrounding positions		*/		private function getConnections(row:int,col:int):void		{			connArray.push(row+","+col);			var odd:uint=row%2;			for (var i:int= -1; i<=1; i++)			{				for (var j: int= -1; j<=1; j++)				{					if (i!=0 || j !=0)					{						if (i==0 || j==0 || (j== -1 && odd ==0) || (j==1 && odd==1))						{							if (isNewConnection(row+i, col+j))							{								if (row+i==0)									connArray[0] = "connected";								else									getConnections(row+i,col+j);							}						}					}				}			}		} //end of getConnections function 				/*		* A function used to discover		* when a bubble is no longer connected to the grid		* and removes it from the field		*/		private function removeNotConnected():void		{			for (var i:uint=1; i<13; i++)			{				for (var j:uint=0; j<8; j++)				{					if (getValue(i,j)>0)					{						connArray=new Array();						getConnections(i,j);						if (connArray [0] != "connected")						{							with (bubCont) 							{								removeChild(getChildByName(i+","+j));							}							fieldArray[i][j]=0;						}					}				}			}		}//end of removeNotConnectedFunction 	}	}